#include "mesh.hpp"

namespace Graphic{

	using namespace glm;

	// An array of 3 vectors which represents 3 vertices
	static const GLfloat g_vertex_buffer_data[] = {
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		0.0f, 1.0f, 0.0f,
	};
	/*
	static const GLfloat g_vertex_buffer_data2[] = {
		-1.0f, -1.0f, -1.0f, // triangle 1 : begin
		-1.0f, -1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f, // triangle 1 : end
		1.0f, 1.0f, -1.0f, // triangle 2 : begin
		-1.0f, -1.0f, -1.0f,
		-1.0f, 1.0f, -1.0f, // triangle 2 : end
		1.0f, -1.0f, 1.0f,
		-1.0f, -1.0f, -1.0f,
		1.0f, -1.0f, -1.0f,
		1.0f, 1.0f, -1.0f,
		1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f, -1.0f,
		1.0f, -1.0f, 1.0f,
		-1.0f, -1.0f, 1.0f,
		-1.0f, -1.0f, -1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f, -1.0f, 1.0f,
		1.0f, -1.0f, 1.0f,
		1.0f, 1.0f, 1.0f,
		1.0f, -1.0f, -1.0f,
		1.0f, 1.0f, -1.0f,
		1.0f, -1.0f, -1.0f,
		1.0f, 1.0f, 1.0f,
		1.0f, -1.0f, 1.0f,
		1.0f, 1.0f, 1.0f,
		1.0f, 1.0f, -1.0f,
		-1.0f, 1.0f, -1.0f,
		1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f, -1.0f,
		-1.0f, 1.0f, 1.0f,
		1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f,
		1.0f, -1.0f, 1.0f
	}; */

	Mesh::Mesh():
		m_modelMatrix(1.f)
	{
		m_vertices.resize(sizeof(g_vertex_buffer_data)/(3*sizeof(GLfloat)));
		memcpy(&m_vertices[0], g_vertex_buffer_data, sizeof(g_vertex_buffer_data));
	}

	void Mesh::updateNormals()
	{
		m_normals.resize(m_vertices.size());
		for (size_t i = 0; i < m_vertices.size(); i += 3)
		{
			vec3 edge1 = m_vertices[i+1] - m_vertices[i];
			vec3 edge2 = m_vertices[i + 2] - m_vertices[i];
			vec3 normal = normalize(cross(edge1, edge2));
			m_normals[i] = normal;
			m_normals[i+1] = normal;
			m_normals[i+2] = normal;

		}
	}
}